# Tests for the "testutils" command, defined in testutils.tcl
#
# Â© 2025 Erik Leunissen
#
# See the file "license.terms" for information on usage and redistribution of
# this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

package require tcltest 2.2
eval tcltest::configure $argv
tcltest::loadTestedCommands

# Notes:
#
# - All tests have been constrained with test constraint "testutils". This
#   constraint isn't set anywhere, and therefore false by default. Therefore,
#   the tests in this file are skipped in a regular invocation of the Tk test
#   suite. In order to run these test, you need to use the tcltest option
#   "-constraints testutils" in the invocation, possibly combined with the
#   option "-file testutils.test" to exclude other test files, or with
#   "-limitconstraints true" to exclude other tests.
#
# - At this place in the test file, the file "testutils.tcl" has already been
#   sourced (through tcltest::loadTestedCommands above), and the utility procs
#   from domain "generic" are already available. Therefore we can make use of
#   proc "assert" here.
#

assert {"testutils" in [info procs testutils]}

#
# Sections 1 - 3: invalid invocations
#
test testutils-1.0 {invalid subcommand} -constraints testutils -body {
    testutils foo
} -result {invalid subCmd "foo". Usage: testutils export|import|forget ?domain domain ...?} -returnCodes error

test testutils-2.0 {invalid #args for subCmd export} -constraints testutils -body {
    testutils export foo
} -result {invalid #args. Usage: testutils export} -returnCodes error

test testutils-2.1 {invalid #args for subCmd import} -constraints testutils -body {
    testutils import
} -result {invalid #args. Usage: testutils import|forget domain ?domain ...?} -returnCodes error

test testutils-2.2 {invalid #args for subCmd forget} -constraints testutils -body {
    testutils forget
} -result {invalid #args. Usage: testutils import|forget domain ?domain ...?} -returnCodes error

test testutils-3.1 {invalid domain for subCmd import} -constraints testutils -body {
    testutils import foo
} -result {testutils domain "foo" doesn't exist} -returnCodes error

test testutils-3.2 {invalid domain for subCmd forget} -constraints testutils -body {
    testutils forget foo
} -result {testutils domain "foo" doesn't exist} -returnCodes error

#
# Create a domain namespace for testing export, import, forget
#
assert {"::tk::test::_foo" ni [namespace children ::tk::test]}
assert {"::tk::test::_zez" ni [namespace children ::tk::test]}
assert {"init" ni [info procs init]}
assert {"_kuk" ni [info procs _kuk]}
assert {"_bar" ni [info vars _bar]}
assert {"_pip" ni [info vars _pip]}

namespace eval ::tk::test::_foo {
    proc init {} {
	variable _bar 123
	variable _pip
    }
    proc _kuk {} {}
    testutils export
}
set initVars [info vars]; lappend initVars initVars

#
# 4. Domain failures for forget and import
#
test testutils-4.0 {forget not-imported domain} -constraints testutils -body {
    testutils forget _foo
} -result {domain "_foo" was not imported} -returnCodes error

test testutils-4.1 {duplicate import} -constraints testutils -body {
    testutils import _foo
    testutils import _foo
} -result {testutils domain "_foo" was already imported} -returnCodes error -cleanup {
    testutils forget _foo
}

#
# 5. Import procs
#
test testutils-5.0 {utility proc is imported and init proc is not} -constraints testutils -body {
    testutils import _foo
    expr {([info procs _kuk] eq "_kuk") && ([info procs init] eq "")}
} -result 1 -cleanup {
    testutils forget _foo
}

test testutils-5.1 {forget removes utility proc} -constraints testutils -body {
    testutils import _foo
    testutils forget _foo
    info procs _kuk
} -result {}

test testutils-5.2 {import fails: proc already exists} -constraints testutils -setup {
    namespace eval ::_zez {
	proc _kuk {} {}
    }
} -body {
    namespace eval ::_zez {
	testutils import _foo
    }
} -result "import from testutils domain \"_foo\" failed: can't import command \"_kuk\": already exists" -returnCodes error -cleanup {
    namespace delete ::_zez
}

#
# 6. Import variables
#
test testutils-6.0 {associated variables are imported} -constraints testutils -body {
    testutils import _foo
    set varNames [info vars]
    foreach name $initVars {
	set varNames [lremove $varNames [lsearch $varNames $name]]
    }
    list [lsort $varNames] [info exists _bar] [info exists _pip] $_bar
} -result [list {_bar _pip} 1 0 123] -cleanup {
    unset -nocomplain name varNames
    testutils forget _foo
}

test testutils-6.1 {
    Repeated initialization keeps imported variable defined without value non-existent,
    even if a test file inadvertently assigns it a value in the meantime.
} -constraints testutils -body {
    catch {
	testutils import _foo
    }
    testutils forget _foo
    set _pip 11111
    testutils import _foo
    info exists _pip
} -result 0 -cleanup {
    testutils forget _foo
}

test testutils-6.2 {import fails: variable already exists} -constraints testutils -setup {
    #
    # We need a pristine new namespace in which the variable _bar was never imported
    # and hence no upvar link for it exists.
    #
    namespace eval ::_zez {
	set _bar 11
    }
} -body {
    namespace eval ::_zez {
	testutils import _foo
    }
} -result "import from testutils domain \"_foo\" failed: variable \"_bar\" already exists" -returnCodes error -cleanup {
    namespace delete ::_zez
}

test testutils-6.3 {repeated creation/deletion of requesting namespace doesn't fool testutils} -constraints testutils -setup {
} -body {
    namespace eval ::_zez {
	testutils import _foo
	testutils forget _foo
    }
    namespace delete ::_zez
    namespace eval ::_zez {
	set _pip 22
	testutils import _foo
	list [info exists _bar] [info exists _pip] $_bar
    }
} -result {1 0 123} -cleanup {
    namespace delete ::_zez
}

#
# CLEANUP
#

namespace delete ::tk::test::_foo
unset initVars
cleanupTests

# EOF
